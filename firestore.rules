rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userID) {
      return isAuthenticated() && request.auth.uid == userID;
    }
    
    function isChatMember(chatID) {
      return isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatID)).data.members;
    }
    
    function validUserData() {
      let data = request.resource.data;
      return data.id == request.auth.uid
        && data.displayName is string
        && data.displayName.size() >= 1
        && data.displayName.size() <= 50
        && data.email is string
        && data.email.matches('[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}');
    }
    
    function immutableFields() {
      let data = request.resource.data;
      let existingData = resource.data;
      return data.id == existingData.id
        && data.email == existingData.email
        && data.createdAt == existingData.createdAt;
    }
    
    // PRODUCTION SECURITY RULES
    
    // Users collection rules
    match /users/{userID} {
      // Anyone authenticated can read any user profile (for contact discovery)
      allow read: if isAuthenticated();
      
      // Only the user can create their own profile with valid data
      allow create: if isOwner(userID) && validUserData();
      
      // Users can update their own profile OR update FCM token
      allow update: if isAuthenticated() && (
        // Own profile update with immutable fields preserved
        (isOwner(userID) && immutableFields())
        ||
        // FCM token update (for notifications)
        (request.auth.uid == userID 
         && request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['fcmToken', 'lastTokenUpdate']))
      );
      
      // No one can delete user documents (admin only, not implemented here)
      allow delete: if false;
    }
    
    // Chats collection rules (PR #4 - Group Chat)
    match /chats/{chatID} {
      // Users can read chats they are members of
      allow read: if isAuthenticated() && request.auth.uid in resource.data.members;
      
      // Users can create chats where they are members
      allow create: if isAuthenticated() && request.auth.uid in request.resource.data.members;
      
      // Users can update chats they are members of (for typing indicators, last message, etc.)
      allow update: if isAuthenticated() && request.auth.uid in resource.data.members;
      
      // No one can delete chats (admin only, not implemented here)
      allow delete: if false;
    }
    
    // Messages subcollection rules (PR #6 - Message Send, PR #12 - Read Receipts)
    match /chats/{chatID}/messages/{messageID} {
      // Users can read messages from chats they are members of
      allow read: if isChatMember(chatID);
      
      // Users can create messages in chats they are members of
      // AND they must be the sender (prevents impersonation)
      allow create: if isChatMember(chatID)
        && request.auth.uid == request.resource.data.senderID;
      
      // Users can update messages in chats they are members of for:
      // 1. Own messages (for status updates, edits)
      // 2. Read receipts (readBy, readAt, status fields)
      allow update: if isChatMember(chatID)
        && (
          // Allow updating own messages
          request.auth.uid == resource.data.senderID
          ||
          // Allow updating read receipts
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy', 'readAt', 'status'])
        );
      
      // No one can delete messages (admin only, not implemented here)
      allow delete: if false;
    }
    
    // Allow list operations on messages subcollection (for fetching messages)
    match /chats/{chatID}/messages {
      allow list: if isChatMember(chatID);
    }
  }
}
