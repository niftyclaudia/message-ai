//
//  SummaryService.swift
//  MessageAI
//
//  Service for managing Focus Mode session summaries
//

import Foundation
import FirebaseFirestore
import FirebaseAuth

/// Service for managing Focus Mode session summaries
@MainActor
class SummaryService: ObservableObject {
    
    // MARK: - Published Properties
    
    /// Current summary being displayed
    @Published var currentSummary: FocusSummary?
    
    /// Summary history
    @Published var summaryHistory: [FocusSummary] = []
    
    /// Loading state for summary operations
    @Published var isLoading: Bool = false
    
    /// Error state for summary operations
    @Published var error: Error?
    
    // MARK: - Private Properties
    
    /// Firestore database instance
    private let db = Firestore.firestore()
    
    /// Current user ID
    private var currentUserID: String? {
        return Auth.auth().currentUser?.uid
    }
    
    /// Cloud Functions base URL
    private let cloudFunctionsBaseURL = "https://us-central1-messageai-2cf12.cloudfunctions.net"
    
    // MARK: - Public Methods
    
    /// Generates a summary for a completed session
    /// - Parameter sessionID: ID of the session to summarize
    /// - Returns: Generated summary
    func generateSessionSummary(sessionID: String) async throws -> FocusSummary {
        guard let userID = currentUserID else {
            throw SummaryError.notAuthenticated
        }
        
        isLoading = true
        error = nil
        
        do {
            // Wait for summary to be generated by Cloud Function trigger
            // Poll for summary availability
            let summary = try await waitForSummaryGeneration(sessionID: sessionID, userID: userID)
            
            currentSummary = summary
            isLoading = false
            
            return summary
            
        } catch {
            isLoading = false
            self.error = error
            throw error
        }
    }
    
    /// Gets a summary by session ID
    /// - Parameter sessionID: ID of the session
    /// - Returns: Summary if found, nil otherwise
    func getSessionSummary(sessionID: String) async throws -> FocusSummary? {
        guard let userID = currentUserID else {
            throw SummaryError.notAuthenticated
        }
        
        do {
            let snapshot = try await db.collection(FocusSummary.collectionName)
                .whereField("sessionID", isEqualTo: sessionID)
                .whereField("userID", isEqualTo: userID)
                .limit(to: 1)
                .getDocuments()
            
            if let document = snapshot.documents.first {
                let summary = try document.data(as: FocusSummary.self)
                return summary
            } else {
                return nil
            }
            
        } catch {
            self.error = error
            throw error
        }
    }
    
    /// Gets recent summaries
    /// - Parameter limit: Maximum number of summaries to retrieve
    /// - Returns: Array of recent summaries
    func getRecentSummaries(limit: Int = 10) async throws -> [FocusSummary] {
        guard let userID = currentUserID else {
            throw SummaryError.notAuthenticated
        }
        
        do {
            let snapshot = try await db.collection(FocusSummary.collectionName)
                .whereField("userID", isEqualTo: userID)
                .order(by: "generatedAt", descending: true)
                .limit(to: limit)
                .getDocuments()
            
            let summaries = try snapshot.documents.compactMap { document in
                try document.data(as: FocusSummary.self)
            }
            
            summaryHistory = summaries
            return summaries
            
        } catch {
            self.error = error
            throw error
        }
    }
    
    /// Exports a summary in the specified format
    /// - Parameters:
    ///   - summary: Summary to export
    ///   - format: Export format
    /// - Returns: Export data
    func exportSummary(summary: FocusSummary, format: ExportFormat) async throws -> Data {
        let exportText = summary.generateExportData(format: format)
        
        guard let data = exportText.data(using: .utf8) else {
            throw SummaryError.exportFailed
        }
        
        return data
    }
    
    /// Retries summary generation for a failed session
    /// - Parameter sessionID: ID of the session to retry
    /// - Returns: Generated summary
    func retrySummaryGeneration(sessionID: String) async throws -> FocusSummary {
        // This would trigger the Cloud Function to regenerate the summary
        // For now, we'll just wait for the existing trigger to complete
        return try await generateSessionSummary(sessionID: sessionID)
    }
    
    // MARK: - Private Methods
    
    /// Waits for summary generation to complete
    /// - Parameters:
    ///   - sessionID: ID of the session
    ///   - userID: ID of the user
    /// - Returns: Generated summary
    private func waitForSummaryGeneration(sessionID: String, userID: String) async throws -> FocusSummary {
        let maxWaitTime: TimeInterval = 30.0 // 30 seconds max wait
        let pollInterval: TimeInterval = 2.0 // Poll every 2 seconds
        let startTime = Date()
        
        while Date().timeIntervalSince(startTime) < maxWaitTime {
            // Check if summary exists
            if let summary = try await getSessionSummary(sessionID: sessionID) {
                return summary
            }
            
            // Wait before next poll
            try await Task.sleep(nanoseconds: UInt64(pollInterval * 1_000_000_000))
        }
        
        throw SummaryError.generationTimeout
    }
    
    /// Makes HTTP request to Cloud Function
    /// - Parameters:
    ///   - endpoint: API endpoint
    ///   - parameters: Query parameters
    /// - Returns: Response data
    private func makeCloudFunctionRequest(endpoint: String, parameters: [String: String]) async throws -> Data {
        guard let userID = currentUserID else {
            throw SummaryError.notAuthenticated
        }
        
        // Get Firebase ID token for authentication
        guard let idToken = try await Auth.auth().currentUser?.getIDToken() else {
            throw SummaryError.notAuthenticated
        }
        
        var urlComponents = URLComponents(string: "\(cloudFunctionsBaseURL)/\(endpoint)")
        urlComponents?.queryItems = parameters.map { URLQueryItem(name: $0.key, value: $0.value) }
        
        guard let url = urlComponents?.url else {
            throw SummaryError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("Bearer \(idToken)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw SummaryError.invalidResponse
        }
        
        guard httpResponse.statusCode == 200 else {
            throw SummaryError.httpError(httpResponse.statusCode)
        }
        
        return data
    }
}

// MARK: - Error Types

enum SummaryError: LocalizedError {
    case notAuthenticated
    case summaryNotFound
    case generationTimeout
    case exportFailed
    case invalidURL
    case invalidResponse
    case httpError(Int)
    case firestoreError(String)
    
    var errorDescription: String? {
        switch self {
        case .notAuthenticated:
            return "User not authenticated"
        case .summaryNotFound:
            return "Summary not found"
        case .generationTimeout:
            return "Summary generation timed out"
        case .exportFailed:
            return "Failed to export summary"
        case .invalidURL:
            return "Invalid URL"
        case .invalidResponse:
            return "Invalid response"
        case .httpError(let code):
            return "HTTP error: \(code)"
        case .firestoreError(let message):
            return "Firestore error: \(message)"
        }
    }
}

// MARK: - FocusSummary Extensions

extension FocusSummary {
    /// Converts FocusSummary to Firestore-compatible data
    func toFirestoreData() throws -> [String: Any] {
        var data: [String: Any] = [
            "id": id,
            "sessionID": sessionID,
            "userID": userID,
            "generatedAt": Timestamp(date: generatedAt),
            "overview": overview,
            "actionItems": actionItems,
            "keyDecisions": keyDecisions,
            "messageCount": messageCount,
            "confidence": confidence,
            "processingTimeMs": processingTimeMs,
            "method": method,
            "sessionDuration": sessionDuration
        ]
        
        if let exportData = exportData {
            data["exportData"] = exportData
        }
        
        return data
    }
}
