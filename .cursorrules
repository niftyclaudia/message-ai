# MessageAI Agent Rules

## Quick Agent Commands

When you see a message like "cody pr-3" or "pete pr-5", automatically use the appropriate agent template:

### Agent Mapping:
- **cody** → Cody Agent (Building/Implementation)
- **kai** → Kai Agent (AI Features Implementation)
- **pete** → Pete Agent (Planning/PRD Creation)  
- **brad** → Brad Agent (PR Brief Builder)
- **quincy** → Quincy Agent (QA Test Architect)

### Usage Pattern:
```
[agent-name] pr-[number]  OR  [agent-name] p[number]  OR  [agent-name] s[number]  OR  [agent-name]2[number]  OR  [agent-name]2 pr[number]
```

**All formats work (for maximum flexibility across branches):**
- `cody pr-3` or `cody p3` or `cody s3` or `cody2 3` or `cody2 pr3` → Same result
- `kai pr-8` or `kai p8` or `kai s8` or `kai2 8` or `kai2 pr8` → Same result (AI features)
- `pete pr-5` or `pete p5` or `pete s5` or `pete2 5` or `pete2 pr5` → Same result  
- `brad pr-1` or `brad p1` or `brad s1` or `brad2 1` or `brad2 pr1` → Same result
- `quincy pr-3 pre-review` or `quincy pr-3 post-review` → Quincy agent for PR #3 (specify mode)

### Template Location:
Use the appropriate agent prompt template based on your current branch:
- **secondagent branch**: `MessageAI/agents/secondagent/agent-prompt-template.md`
- **develop branch**: `MessageAI/agents/agent-prompt-template.md`

Replace in the template:
- `[AGENT_NAME]` with the agent name (Cody, Kai, Pete, Brad, Quincy)
- `[AGENT_ROLE]` with their role description
- `[agent-type]` with the agent type (cody, kai, pete, brad, quincy)
- `[NUMBER]` with the PR number

### Examples:
- "cody pr-3", "cody p3", or "cody s3" → Cody agent for PR #3 implementation (regular features)
- "kai pr-8", "kai p8", or "kai s8" → Kai agent for PR #8 implementation (AI features)
- "pete pr-5", "pete p5", or "pete s5" → Pete agent for PR #5 planning
- "brad pr-1", "brad p1", or "brad s1" → Brad agent for PR #1 brief creation
- "quincy pr-3 pre-review" → Quincy agent for PR #3 test plan (before implementation)
- "quincy pr-3 post-review" → Quincy agent for PR #3 test verification (after implementation)

Always reference the specific agent template file for detailed instructions.

---

# Swift Development Rules

Key Concepts for New Developers
Everything goes through the database - GRDB transactions are central
Dependency injection is preferred - Avoid global singletons when possible
Protocol-oriented - Heavy use of Swift protocols
Async/await everywhere - Modern Swift concurrency
Thread safety - Always consider which queue/thread you're on
Modular architecture - Clear layer separation (UI → SignalUI → SignalServiceKit)

## Project Context
- Swift 5.0
- Focus on main thread safety and responsive UI

## Threading & Concurrency Rules

### Always Use Background Threads For:
- Network requests (URLSession, API calls)
- File I/O operations (reading/writing files)
- Database operations (Core Data, Realm, SQLite)
- Heavy computations or data processing
- Image processing or resizing
- JSON parsing of large data

### Always Use Main Thread For:
- Updating UI elements (labels, buttons, views)
- Presenting/dismissing view controllers
- Reloading table views or collection views
- Any UIKit or SwiftUI view updates

### Code Patterns to Follow:

**For async work returning to main thread:**
```swift
DispatchQueue.global(qos: .userInitiated).async {
    // Heavy work here
    let result = performExpensiveOperation()
    
    DispatchQueue.main.async {
        // Update UI here
        self.label.text = result
    }
}
```

**For network calls:**
```swift
URLSession.shared.dataTask(with: url) { data, response, error in
    // This is already on background thread
    guard let data = data else { return }
    
    // Parse data on background
    let parsed = parseData(data)
    
    // Switch to main for UI updates
    DispatchQueue.main.async {
        self.updateUI(with: parsed)
    }
}.resume()
```

## Code Review Checklist
- [ ] No network calls on main thread
- [ ] UI updates wrapped in `DispatchQueue.main.async`
- [ ] Heavy operations use background queues
- [ ] No synchronous file operations on main thread
- [ ] Table/collection view reloads on main thread

## Common Mistakes to Avoid
- Don't use `.sync` on main queue (causes deadlock)
- Don't forget to weakly capture `self` in closures: `[weak self]`
- Don't access UI elements from background threads
- Don't block main thread with `sleep()` or long loops

## Quality of Service (QoS) Guide
- `.userInteractive`: UI updates, animations (main thread)
- `.userInitiated`: User-requested tasks (e.g., loading data after tap)
- `.utility`: Long-running tasks with progress (downloads)
- `.background`: Non-urgent maintenance (cleanup, sync)
